= Prüfschritt 11.4.1.2 Name, Rolle, Wert verfügbar
include::include/author.adoc[]
include::include/attributes.adoc[]

== Was wird geprüft?

Alle Bedienelemente einer Software (also etwa Tasten, oder Formularelemente wie Checkboxen oder Eingabefelder) müssen semantische Informationen (Name, Rolle, Wert) programmatisch bereitstellen, damit Hilfsmittel wie Screenreader diese richtig erkennen und bedienen können. Bei nativen Elementen, also solchen, die mit den Standardelementen der Entwicklungsumgebungen umgesetzt sind, ist dies in der Regel ohne weiteres Zutun gegeben. 

Bei selbsterstellten Bedienelementen von Apps müssen semantische Informationen wie Name, Rolle und Wert gegebenenfalls explizit definiert werden, damit Hilfsmittel diese Elemente erkennen.

Bei Software werden dazu die Accessibility-Schnittstellen des jeweiligen Betriebssystems genutzt.

== Warum wird das geprüft?

Für sehende Nutzer sind Bedienelemente in der Regel leicht erkannbar und verständlich, wenn sie konventionell, also häufig in gleicher Weise eingesetzt sind. Beispiele wären etwa ein Menü-Tasten aus drei horizontalen Strichen (das sogenannte "Hamburger"-Icon) oder ein Lupen-Icon zum Auslösen einer Suche. Bei vielen Tasten und Eingabefeldern macht die Beschriftung das Element verständlich. Für Hilfsmittel-Nutzende ist es entscheidend, dass Namen, Rollen und Werte von Bedienelementen auch programmatisch verfügbar sind. Wenn ein Element - etwa ein grafischer Menü-Schalter - erreicht wird, wird an Screenreader-Nutzende ausgegeben: "Navigationsmenü, Schaltfläche, reduziert". "Navigationsmenü" ist der hinterlegte Name, "Schaltfläche" die Rolle, und "reduziert" der Wert bzw. Zustand. Nutzende wissen dann, dass die Aktivierung dieses Elements ein Navigationsmenü öffnen wird. 

Wenn Bedienelemente mit den von der Entwicklungsumgebung bereitgestellten Standard-Schnittstellen-Elementen umgesetzt werden, sind Rollen und Zustände in der Regel ohne weiteres Zutun programmatisch verfügbar. So sollten in iOS etwa Textfelder über das Standardelement `UITextField` umgesetzt werden und Schalter als `UIButton`. Werden andere als die Standardelemente eingesetzt, etwa ein Bild, das als Schalter eingesetzt wird, gibt es je nach Plattform geeignete Wege, um Namen, Rollen (die Art des Bedienelements) und Werte bzw. typisches Verhalten des Elements programmatisch zu setzen. Wenn das geschieht, ist die Semantik auch bei nicht-visueller Nutzung verfügbar, z. B. beim Einsatz des systemseitigen Screenreaders. Bei IOS dienen dazu etwa das Attribut https://developer.apple.com/documentation/objectivec/nsobject/1615181-accessibilitylabel[`AccessibilityLabel`] zur Hinterlegung eines Namens und die https://developer.apple.com/documentation/objectivec/nsobject/uiaccessibility/accessibility_traits[Accessibility Traits] zur Definition der Rolle und des Verhaltens. Bei Android leistet dies das https://developer.android.com/guide/topics/ui/accessibility/apps#describe-ui-element[`contentDescription`]-Attribut. So kann das Betriebssystem diese Werte an Hilfstechnologien wie Screenreader weiterreichen.

== Wie wird geprüft?

=== Anwendbarkeit des Prüfschritts

Der Prüfschritt ist immer anwendbar, wenn die App Bedienelemente einsetzt. Aus Nutzersicht ist nicht immer zu erkennen, ob die Bedienelemente vom Betriebssystem bereitgestellt werden (und damit quasi von Haus aus zugänglich sind) oder vom Entwickler selbst definiert wurden. Eine Sichtprüfung reicht deshalb *nicht* aus. Bedienelemente müssen mit dem Screenreader fokussiert und aktiviert werden, um festzustellen, ob die jeweiligen Namen, Rollen und Werte vom Screenreader ausgegeben werden und auch Zustandsänderungen richtig vermittelt werden.

=== Prüfung

. Screenreader starten. 
.. Bei iOS/iPadOS geht dies über Einstellungen -> Allgemein -> Bedienungshilfen -> VoiceOver oder, wenn der Kurzbefehl für Bedienungshilfen so eingestellt ist, dass er VoiceOver aktiviert, über dreimaliges Drücken der Home-Taste am Gerät. 
.. Bei Android geht dies über Einstellungen -> Eingabehilfe  -> Talkback, oder, wenn der Kurzbefehl so eingestellt ist, dass er TalkBack aktiviert, über ein gleichzeitiges langes Drücken der beiden Tasten zur Lautstärkeregelung am Gerät.
. Software mit zu prüfender Ansicht starten
. Alle Bedienelemente mit dem Screenreader untersuchen: Wird der Name, die Rolle und der Wert des Bedienelements vom Screenreader korrekt
  ausgegeben? Wird der ggf. geänderte Wert des Elements nach Eingabe korrekt ausgegeben?
+
Der Name ist dabei der Name des Bedienelements und ist meist gleichlautend mit dem Label des Bedienelements. Z. B. "Nachname" für ein Eingabefeld.
+
Zu den Rollen gehören u. a. "Taste" bzw. "Schaltfläche", "Eingabefeld" bzw. "Bearbeitungsfeld", "Suchfeld", "Ausklappliste", und "Markierungsfeld" bzw. "Kästchen".
+
Der Wert beschreibt z. B. den Inhalt des Bedienelements z. B. "Müller" bei einem Eingabefeld für Nachnamen. Zu den Werten des Bedienelements gehört auch der aktuelle Status, z. B. "ausgewählt" für ein ausgewählten Listeneintrag oder eine angekreuzte Checkbox.

==== Rollen von iOS / iPadOS und Android

Bei der Prüfung von Bedienelementen mit dem Screenreader, müssen die korrekten Rollen angesagt werden. Einige wichtige Rollen stellen wir in der Folgenden Tabelle bereit:

[%header,format=csv,separator=;]
|===
include::include/Rollen.csv[]
|===

=== Hinweise

Dieses Erfolgskriterium richtet sich in erster Linie an Softwareentwickler,
die benutzerdefinierte bzw. selbstgestaltete Komponenten für die
Benutzeroberfläche entwickeln oder einsetzen.
Standard-Benutzeroberflächenkomponenten auf den meisten barrierefrei
gestalteten Plattformen erfüllen dieses Erfolgskriterium bereits bei
bestimmungsgemäßer Verwendung.

Um diesem Erfolgskriterium gerecht zu werden, ist es in der Regel
empfehlenswert, dass Software-Benutzeroberflächen die
Barrierefreiheitsdienste der Plattformsoftware nutzen.
Diese Zugänglichkeitsdienste ermöglichen die Interoperabilität zwischen
Software-Benutzeroberflächen und sowohl unterstützenden Technologien als
auch Zugänglichkeitsfunktionen von Software auf standardisierte Weise.
Die meisten Dienste zur Zugänglichkeit der Plattform gehen über die
programmatische Offenlegung von Namen und Rolle und die programmatische
Einstellung von Zuständen, Eigenschaften und Werten (und deren
Benachrichtigung) hinaus und spezifizieren zusätzliche Informationen, die
offengelegt werden könnten oder sollten (z.B. eine Liste der verfügbaren
Aktionen für eine bestimmte Komponente der Benutzeroberfläche und ein Mittel
zur programmatischen Ausführung einer der aufgeführten Aktionen).

Bei selbstgestalteten Bedienelementen (custom controls) müssen Entwickler plattformspezifische Methoden und Schnittstellen verwenden, um diese Elemente barrierefrei umzusetzen.
Unter iOS / iPadOS sind dazu u. a. https://developer.apple.com/documentation/objectivec/nsobject/uiaccessibility/accessibility_traits[
Accessibility Traits] zu verwenden.

=== Bewertung

*Nicht erfüllt:*

* wichtige Bedienelemente sind mit Custom Controls umgesetzt, auf eine
  Nachbildung der Semantik für die Barrierefreiheitsschnittstellen des
  Systems, wurde verzichtet

== Einordnung des Prüfschritts

=== Abgrenzung von anderen Prüfkriterien

* In diesem Prüfschritt geht es nicht um die Bewertung der
  Tastaturbedienbarkeit  von selbsterstellten Bedienelementen.
  Dies ist Gegenstand von Prüfschritt
ifdef::env_embedded[11.2.1.1 "Tastaturbedienung".]
ifndef::env_embedded[]
  <<11.2.1.1 Tastaturbedienung.adoc#,11.2.1.1 Tastaturbedienung>>.
endif::env_embedded[]

=== Einordnung des Prüfschritts nach WCAG 2.1

==== Guideline

* https://www.w3.org/TR/WCAG21/#compatible[Guideline 4.1 Compatible]:
  Maximize compatibility with current and future user agents, including
  assistive technologies.

==== Success criterion

* https://www.w3.org/TR/WCAG21/#name-role-value[4.1.2 Name, Role, Value
  (Level A)]

==== Techniques

.General Techniques
* https://www.w3.org/WAI/WCAG21/Techniques/general/G10.html[G10: Creating
  components using a technology that supports the accessibility API features
  of the platforms on which the user agents will be run to expose the names
  and roles, allow user-settable properties to be directly set, and provide
  notification of changes]
* https://www.w3.org/WAI/WCAG21/Techniques/general/G108.html[G108: Using
  markup features to expose the name and role, allow user-settable properties
  to be directly set, and provide notification of changes]
* https://www.w3.org/WAI/WCAG21/Techniques/general/G135.html[G135: Using the
  accessibility API features of a technology to expose names and roles, to
  allow user-settable properties to be directly set, and to provide
  notification of changes]

==== Failures

* https://www.w3.org/WAI/WCAG21/Techniques/failures/F15.html[F15: Failure of
  Success Criterion 4.1.2 due to implementing custom controls that do not use
  an accessibility API for the technology, or do so incompletely]
* https://www.w3.org/WAI/WCAG21/Techniques/failures/F20.html[F20: Failure of
  Success Criterion 1.1.1 and 4.1.2 due to not updating text alternatives when
  changes to non-text content occur]
* https://www.w3.org/WAI/WCAG21/Techniques/failures/F59.html[F59: Failure of
  Success Criterion 4.1.2 due to using script to make div or span a user
  interface control in HTML]
* https://www.w3.org/WAI/WCAG21/Techniques/failures/F79.html[F79: Failure of
  Success Criterion 4.1.2 due to the focus state of a user interface component
  not being programmatically determinable or no notification of change of
  focus state available]

== Quellen

=== Ressourcen für Entwickler

==== iOS Developer: ====

* https://developer.apple.com/documentation/uikit/uiaccessibility/uiaccessibilitytraits[UIAccessibilityTraits]
* https://developer.apple.com/documentation/swiftui/accessibilitytraits[AccessibilityTraits]

==== Android Developer: ====
*  https://developer.android.com/reference/android/accessibilityservice/package-summary[android.accessibilityservice]
